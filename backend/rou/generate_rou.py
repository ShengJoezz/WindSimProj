#!/usr/bin/env python3
import argparse, os, sys, subprocess, tempfile, glob, math, yaml
import numpy as np
import rasterio as rio
from rasterio.enums import Resampling
from rasterio.transform import Affine

def utm_epsg(lat, lon):
    zone = int((lon + 180.0) // 6 + 1)
    return 32600 + zone if lat >= 0 else 32700 + zone

def run(cmd):
    p = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    if p.returncode != 0:
        print("CMD failed:", " ".join(cmd))
        print(p.stderr)
        sys.exit(1)
    return p.stdout

def build_vrt_from_dir(indir, vrt_path, pattern="*.tif"):
    files = sorted(glob.glob(os.path.join(indir, pattern)))
    if not files:
        print(f"No tif found in {indir}")
        sys.exit(1)
    run(["gdalbuildvrt", "-q", vrt_path, *files])

def warp_clip(src_path, dst_path, epsg, x0, y0, r2, res=None):
    R = float(r2) * 1.05  # 小缓冲
    xmin, ymin, xmax, ymax = x0 - R, y0 - R, x0 + R, y0 + R
    cmd = [
        "gdalwarp",
        "-t_srs", f"EPSG:{epsg}",
        "-r", "near",
        "-te_srs", f"EPSG:{epsg}",
        "-te", str(xmin), str(ymin), str(xmax), str(ymax),
        "-dstNodata", "0",
        "-co", "COMPRESS=LZW",
        "-co", "BIGTIFF=YES",
        src_path, dst_path
    ]
    if res:
        cmd[1:1] = ["-tr", str(res), str(res)]
    run(cmd)

def write_rou(out_path, xs, ys, z0v, hv, quant=0.5):
    # 量化 h 以便分组
    hq = np.round(hv / quant) * quant
    unique_h = np.unique(hq)
    with open(out_path, "w", encoding="utf-8") as f:
        f.write("+rou - generated by generate_rou.py\n0 0 0 0\n0 0 0 0\n0 0 0 0\n")
        for hval in unique_h:
            idx = np.where(hq == hval)[0]
            if idx.size == 0:
                continue
            z0_mean = float(np.mean(z0v[idx])) if idx.size > 0 else 0.0
            f.write(f"{z0_mean:.3f} {hval:.3f} {idx.size}\n")
            for k in idx:
                f.write(f"{xs[k]:.3f} {ys[k]:.3f}\n")

def main():
    ap = argparse.ArgumentParser(description="Generate Input/rou from CLCD land cover")
    g = ap.add_mutually_exclusive_group(required=True)
    g.add_argument("--clcd", help="Path to CLCD national TIFF (Albers)")
    g.add_argument("--clcd-dir", help="Directory of provincial TIFFs (Albers)")
    ap.add_argument("--center", required=True, help="lat,lon of domain center (deg)")
    ap.add_argument("--r2", type=float, required=True, help="radius (m) to cover (use terrain.r2 or larger)")
    ap.add_argument("--out", default="Input/rou", help="output rou path")
    ap.add_argument("--mapping", default="mapping.yaml", help="class->z0 mapping yaml")
    ap.add_argument("--a", type=float, default=None, help="override a in h=a*z0 (if not set, read from yaml)")
    ap.add_argument("--vege-times", type=float, default=1.0, help="global multiplier on h")
    ap.add_argument("--sample", type=float, default=100.0, help="sampling spacing in meters (≈ cee)")
    ap.add_argument("--quant", type=float, default=None, help="quantization step for h (m)")
    args = ap.parse_args()

    lat, lon = map(float, args.center.split(","))
    epsg = utm_epsg(lat, lon)

    # 读取映射配置
    if os.path.exists(args.mapping):
        cfg = yaml.safe_load(open(args.mapping, "r", encoding="utf-8"))
        cl2z = cfg.get("clcd_to_z0", {})
        a_fac = args.a if args.a is not None else float(cfg.get("a_factor", 20.0))
        quant = args.quant if args.quant is not None else float(cfg.get("quant_step_m", 0.5))
        default_z0 = float(cfg.get("default_z0", 0.0))
    else:
        print("mapping.yaml not found, using built-in defaults")
        cl2z = {1:0.10,2:0.50,3:0.07,4:0.05,5:0.0002,6:0.001,7:0.02,8:0.40,9:0.07}
        a_fac = args.a if args.a is not None else 20.0
        quant = args.quant if args.quant is not None else 0.5
        default_z0 = 0.0

    os.makedirs(os.path.dirname(args.out) or ".", exist_ok=True)

    with tempfile.TemporaryDirectory() as td:
        src = None
        if args.clcd_dir:
            vrt = os.path.join(td, "clcd.vrt")
            build_vrt_from_dir(args.clcd_dir, vrt)
            src = vrt
        else:
            src = args.clcd

        clip = os.path.join(td, "clip_utm.tif")
        # 先把中心点经纬度转到 UTM 以获取 x0,y0
        try:
            from pyproj import Transformer
            t = Transformer.from_crs(4326, epsg, always_xy=True)
            x0, y0 = t.transform(lon, lat)
        except Exception as e:
            print("pyproj error:", e)
            sys.exit(1)

        warp_clip(src, clip, epsg, x0, y0, args.r2)

        # 按 sample 抽样，读取类别值
        with rio.open(clip) as ds:
            arr = ds.read(1)
            nodata = ds.nodata if ds.nodata is not None else 0
            tr: Affine = ds.transform
            rx, ry = abs(tr.a), abs(tr.e)
            stepx = max(1, int(round(args.sample / rx)))
            stepy = max(1, int(round(args.sample / ry)))
            rows = np.arange(0, ds.height, stepy)
            cols = np.arange(0, ds.width,  stepx)
            sub = arr[np.ix_(rows, cols)]
            # 计算网格中心的世界坐标
            cc = (cols + 0.5)[None, :]
            rr = (rows + 0.5)[:, None]
            X = tr.c + tr.a*cc + tr.b*rr
            Y = tr.f + tr.d*cc + tr.e*rr
            vals = sub.flatten()
            xs = X.flatten().astype("float64")
            ys = Y.flatten().astype("float64")

        # 映射到 z0/h
        z0 = np.array([float(cl2z.get(int(v), default_z0)) for v in vals], dtype="float64")
        h  = (a_fac * z0) * float(args.vege_times)

        # 过滤 nodata（类别=0 或 nodata）
        valid = (vals != nodata) & np.isfinite(vals)
        xs, ys, z0, h = xs[valid], ys[valid], z0[valid], h[valid]

        if xs.size == 0:
            print("No valid samples in the requested area.")
            sys.exit(2)

        write_rou(args.out, xs, ys, z0, h, quant=quant)
        print(f"Wrote rou: {args.out}  (points={xs.size}, EPSG:{epsg}, sample={args.sample} m)")
        print("提示：启用 LonLat2UTM，并确保 input.json->domain 的 lat/long 是上面 center 的真实值。")

if __name__ == "__main__":
    main()